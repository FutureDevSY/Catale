# B306 TIL Week1

|월|화|수|목|금|
|:--:|:--:|:--:|:--:|:--:|
|02/26|[02/27](#2024-02-27-화)|[02/28](#2024-02-28-수)|[02/29](#2024-02-29-목)|03/01|






## 2024-02-27 (화)
<details>
<summary>고은석</summary>


**한 일**

* 특화 프로젝트 주제 선정 회의
* k8s 관련 학습
* Git 관련 학습

**배운 것**
* k8s
  - 쿠버네티스의 장점
    + 컨테이너화된 어플리케이션 배포 : 컨테이너로 패키징된 어플리케이션을 여러 대의 컴퓨터 또는 클라우드 인프라에 쉽게 배포 가능
    + 자동 스케일링(auto scaling) : 어플리케이션의 부하에 따라 자동으로 서버를 늘리거나 줄일 수 있어 트래픽 증가에 대처가 용이
    + 고가용성(high availability) : 어플리케이션을 여러 서버에 복제하여 하나의 서버에 장애가 발생해도 시스템이 계속 동작 가능
    + 자동 복구(self-healing) : 어플리케이션에 문제 또는 장애가 발생하면 자동으로 복구하거나 롤백이 가능해 시스템 신뢰성 향상
    + 선언적 구성(declarative model) : YAML 또는 JSON 파일을 사용해 어플리케이션이 원하는 상태를 정의하고 그 상태를 유지함

* Git
  - Submodule
    + git 저장소 안에 다른 저장소가 들어가 있는 개념
    + 상위 저장소에서 서브 모듈을 SHA 값, 하나의 바이너리처럼 취급하기 때문에 병합에 있어 복잡
    + 저장소가 병합되는 것이 아닌 최신 커밋의 내용으로 교체된다. 직접 submodule을 업데이트한 뒤 병합 후 push해야 한다.
    + .gitmodules 파일을 통해 메인 프로젝트에서 sub 프로젝트를 관리.
  - Subtree
    + 여러 저장소를 통합하는 개념
    + submodule과는 달리 상위 저장소에 파일을 직접 추가하고 트래킹한다. subtree의 변경사항도 상위 저장소에 기록된다.
    + subtree의 원격 저장소와 subtree를 추가한 저장소의 소스가 달라도 *'subtree merge'* 를 활용하여 양쪽의 변경사항을 모두 반영할 수 있다.
    + subtree는 메인 프로젝트에서 서브 프로젝트를 바로 수정하고 push 할 수 있다는 장점이 존재, 물론 자유도가 높기 때문에 개발 시 주의가 필요!


**더 공부해야 할 내용**

* local에서 쿠버네티스(microk8s)를 통해 클러스터 구성 실습
* 좀 더 편한 devops를 위한, 특화 프로젝트에 어울리는 git repository 구조 생각해보기

</details>



<details>
<summary>서만기</summary>

**한 일**

* 특화프로젝트 주제선정을 위해 아이디어 제시
  - 보드게임 추천 서비스
  - 가계부 다이어리 서비스
  <br>
* TypeScript 강의 시청
  - [TypeScript 기본기](https://www.codeit.kr/topics/typescript-basic)

**배운 것**

* TIL 작성요령
  - TIL은 Today I Learnd의 줄임말.
  - TIL으로 성장 기록 또는 정보기록으로 쓰일 수 있음.
  - 글쓰기또는 사진, 영상, 녹음 등 여러가지로 쓸 수 있음.
  - 꾸준함이 담긴 포트폴리오가 될 수 있으니 노력하는 것이 좋다고 판단.
* 타입스크립트
  - 자바스크립트와 타입스크립트의 차이점
    - 자바스크립트는 컴파일언어(소스 코드를 기계어로 바꿔 놓고 실행하는 언어)가 아닌
      인터프리터 언어(소스 코드를 한 줄씩 읽어서 실행하는 언어)이다.
    - 자바스크립트는 동적 타이핑 언어이다.
        - 변수의 자료형을 자유롭게 바꿔서 사용 가능
        - 장점 - 개발자가 마음대로 편하게 변수를 쓸 수 있음
        - 단점 - 실수하기 쉽고, 실수를 발견하기 어려움
    - 타입스크립트는 정적 타이핑을 지원한다.
    - 타입스크립트는 실제로 배포하기 전에 타입 체크를 한다.
  - [strict mode](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Strict_mode)


**~~아직 잘 모르는 것~~**

**느낀 점**

* 빅데이터기반 추천 서비스라는 도메인으로 주제를 선정할 때의 주의점
  - 추천이라는 한정적인 생각으로만 아이디어를 생각하는 것 때문에 좋은 주제가 나오지 않을 수 있음.
  - 아이디어를 낼 때 무작정 뱉는 것 보다 구체적으로 생각하는 것이 좋을 것 같음.
  - 기존에 있던 프로젝트라도 조그만 옵션을 추가했을때 개발할 가치가 느껴진다면 의미있는 프로젝트가 될 수 있음.
  - 생각한 아이디어가 이미 만들어진 프로젝트라도 추가적으로 디벨롭한다고 생각하는 것이 좋을 것 같음.

</details>



<details>
<summary>심규리</summary>

**한 일**

* 특화 프로젝트 주제 선정 회의
  - IT/CS 관련 기사 추천 서비스
  - 개인 맞춤형 기사 추천
  - 마이페이지 스크랩 기사 모아보기 / 형광펜 기능
* 사회 초년생을 위한 중고차 추천 서비스
* 가구 추천 및 인테리어 추천 서비스
* **JPA 공부 시작하기**

**학습 내용**

* JPA란?
  - JPA는 자바 진영에서 ORM(Object-Relational Mapping) 기술 표준으로 사용되는 인터페이스의 모음을 말한다. 즉, 실제적으로 구현된 것이 아닌, 구현된 클래스와 매핑을 해주기 위해 사용되는 프레임워크이다.

* ORM이란?
  - ORM(Object-Relational Mapping)
  - 객체 지향 프로그래밍 언어를 사용하여 호환되지 않는 유형의 시스템 간에 데이터를 변환하는 프로그래밍 기술을 말한다. 쉽게 말해, ORM은 데이터베이스의 테이블을 프로그래밍 언어에서 사용하는 객체(또는 클래스)로 매핑(연결)하여, 개발자가 보다 객체 지향적인 방식으로 데이터베이스를 조작할 수 있게 도와주는 기술을 의미하는 것이다.
  - 예를 들어, DB에 “USER”테이블이 있다고 했을때, ORM을 사용하지 않는 전통적인 방식에서는 SQL 쿼리를 작성하여 데이터를 조회, 추가, 수정, 삭제해야한다. 그러나, ORM을 사용하면, “USER”테이블을 하나의 클래스로 매핑하고, 이 클래스의 객체를 생성, 조회, 수정 하는 방식으로 DB를 조작할 수 있다.  이렇게 하면 SQL 쿼리를 직접 작성하지 않아도 되기 때문에, 개발자는 비즈니스 로직에 더 집중할 수 있고, 코드의 가독성과 유지보수성이 향상된다.
  - ORM의 장점
    - **개발 효율성**: 데이터베이스 작업을 위한 코드 작성이 간소화되어 개발 시간이 단축됨
    - **유지보수성**: 데이터베이스 구조가 변경되어도 ORM을 사용하는 코드 부분만 수정하면 되므로 유지보수가 용이함
    - **객체 지향적 접근**: 데이터베이스를 객체로 다루기 때문에, 객체 지향 프로그래밍의 장점을 데이터 관리에도 적용할 수 있음
  - ORM의 단점
    - **성능 문제**: ORM을 사용하면 성능이 저하될 수도 있음 (ORM이 생성하는 SQL 쿼리가 최적화되지 않은 경우에 발생할 수 있음)
    - **복잡한 쿼리의 어려움**: 매우 복잡한 쿼리를 ORM으로 표현하려 할 때, 코드가 더 복잡해질 수 있음


**아직 모르는 것**

- ORM의 단점 중, 복잡한 쿼리를 표현하기 어렵다는 점이 있었는데, 이를 보완할 수 있는 방법은 어떤 것이 있을까

</details>



<details>

<summary>유호정</summary>

**한 일**

* 주제 선정 회의
* 팀미팅
* JPA 학습
    - SQL 중심적인 개발의 문제점 및 JPA
    - H2 데이터베이스
    - 데이터베이스 방언

**배운 것**  

* SQL 중심적인 개발의 문제점
    - SQL에 의존적인 개발
    - 패러다임의 불일치
    - 객체답게 모델링 할수록 매핑 작업만 늘어남
* JPA
    - Java Persistence API
    - 자바 진영의 ORM 기술 표준
    - ORM : Object-relational mapping(객체 관계 매핑)
    - SQL 중심적인 개발이 아닌 객체 중심으로 개발
    - 좋은 생산성 및 유지보수
    - 패러다임의 불일치 해결
    - 데이터 접근 추상화와 벤더 독립성
* H2 데이터베이스
    - 용량이 가벼움
    - 웹용 쿼리를 제공
    - MySQL, Oracle 데이터베이스 시뮬레이션
    - 시퀀스, AUTO INCREMENT 기능
* 데이터베이스 방언
    - JPA는 특정 데이터베이스에 종속 되지 않음
    - 각각의 데이터베이스가 제공하는 SQL 문법과 함수는 조금씩 다름 • 가변 문자 MySQL은 VARCHAR, Oracle은 VARCHAR2 • 문자열을 자르는 함수: SQL 표준은 SUBSTRING(), Oracle은 SUBSTR() • 페이징: MySQL은 LIMIT , Oracle은 ROWNUM
방언 : SQL 표준을 지키지 않는 특정 데이터베이스만의 고유한 기능
* Hibernate 데이터베이스 방언 종류
    - H2 : org.hibernate.dialect.H2Dialect
    - Oracle 10g : org.hibernate.dialect.Oracle10gDialect
    - MySQL : org.hibernate.dialect.MySQL5InnoDBDialect

**아직 잘 모르는 것**  

* 데이터베이스 접근정보 넣는 property에 name의 시작 부분이 javaX 와 hibernate 두가지로 나누어 지는데 이 둘의 차이점은 뭘까?

</details>



<details>
<summary>최소영</summary>

* 백준 1043번 - 거짓말 문제풀이

* 각 파티별로 참석하는 인원들의 번호를 ArrayList<>배열에 담았고, 거짓말을 할 수 없는 인원들의 번호를 queue를 이용해 담음. 큐에서 원소들을 하나씩 쳐내가며 큐가 빌 때가지를 반복  횟수로 만들기 위함.
* 처음에는 각 파티별 참여 인원을 2차원 배열에 담았으나, 확인 도중에 참여 인원중 누군가가 거짓말을 할 수 없는 그룹(큐에 담긴 인원들)에 속해있다는 것을 알게 될 경우 반복을 다시 돌리기 불편해진다는 문제 때문에 ArrayList를 사용함.
* ArrayList의 contains메서드를 사용해 먼저 해당 ArrayList 내에 거짓말을 할 수 없는 그룹에 속해있는지부터 파악한 뒤 만약 있다면 거짓말 가능 불가 횟수를 하나 증가, 해당 인원들을 큐에 추가해준다(큐에 없는 원소만을 추가해줌). 
* 원래는 해당 파티에서 거짓말을 할 수 있는지 없는지 여부를 확인할 boolean 1차원 배열을 이용하려고 했으나 그럴 필요가 없었다. 해당 파티에서 거짓말 할 수 없다고 판단될때마다의 횟수를 세어주고, 총 파티의 수에서 그 횟수를 뺀 만큼을 답으로 삼았다..




</details>



<details>
<summary>최준호</summary>

**한 일**

* 주제 선정 회의
* 역할 논의
* TypeScript 학습
    - TypeScript + react 프로젝트

**배운 것**

* TypeScript를 쓰는이유
    - 타입 안정성 및 강력한 타입 시스템: TypeScript는 정적 타입을 지원하여 개발자가 변수, 함수 및 객체 등을 명시적으로 타입을 지정할 수 있다. 이는 코드에서 발생할 수 있는 많은 오류를 런타임이 아닌 개발 단계에서 미리 찾을 수 있게 해준다.
    - 코드 가독성 향상: 명시적인 타입 선언은 코드의 가독성을 향상시키며, 코드를 이해하고 유지보수하기 쉽게 만든다. 특히 큰 규모의 프로젝트에서는 이러한 가독성이 매우 중요하다.
    - 강력한 개발 도구 지원: TypeScript는 강력한 개발 도구를 제공한다. 대표적으로 자동 완성, 리팩토링, 디버깅 등을 지원하여 개발 생산성을 향상시킨다.
    - 효율적인 협업: 정적 타입은 코드의 의도를 더 명확하게 전달하므로 팀 프로젝트에서 협업이 더 원활해진다. 개발자 간의 의사 소통이 강화되고, 코드 변경에 따른 부작용을 사전에 방지할 수 있다.
    - JavaScript와의 호환성: TypeScript는 JavaScript의 상위 집합으로, 기존의 JavaScript 코드를 그대로 사용하면서도 점진적으로 타입을 도입할 수 있다. 이는 기존 프로젝트에서의 적용이나 JavaScript 생태계와의 호환성을 강화해준다.
    - 풍부한 에코시스템: TypeScript는 Microsoft에서 지원하고 있으며, 많은 개발자 및 기업들이 사용하고 있다. 이로 인해 다양한 라이브러리, 프레임워크, 도구 등이 TypeScript를 기반으로 개발되어 있어 풍부한 에코시스템을 지원받을 수 있다.
    - 선진적인 ECMAScript 기능 사용: TypeScript는 ECMAScript 표준을 기반으로 하며, 최신 JavaScript 기능을 먼저 사용할 수 있는 장점이 있다. 이를 통해 개발자는 최신 언어 기능을 더 빠르게 채택할 수 있다.

**아직 잘 모르는 것**

* 리액트에서의 타입스크립트로 프로젝트를 진행하는법이 자바스크립트 만큼 매끄럽지않다.

</details>





## 2024-02-28 (수)

<details>
<summary>고은석</summary>

**한 일**

* 특화 프로젝트 주제 선정
* Git Repository 구조 설계


**배운 것**

* 리뷰 같은 데이터는 다른 주제에 관련된 리뷰 데이터를 가져와서 가공한 후 사용해도 괜찮다.
* 너무 추천이라는 방향에서 생각하지 말고 큰 줄기를 정한 후 추천 기능을 넣는 방향으로 생각해보자
* git submodule
  - submodule은 CBD (component-based development)에 적합한 모델이며, 메인 저장소는 다른 컴포넌트들에 의존적이다.
  - submodule은 실제 저장소의 파일들을 가지는 것이 아니라 링크로 연결된 것이다.
  - submodule은 저장소를 여러개의 저장소로 나눌때 사용한다. 만약 서브모듈에서 변경을 한다면 서브 모듈 안에서 커밋/푸쉬를 한 후에 메인 저장소에서 한번 더 커밋/푸쉬를 해야한다.
* git subtree
  - subtree는 SBD (system-based development)에 더욱 가까우며, 모든 저장소는 모든 저장소의 파일들을 포함하고 있어 각 부분을 수정 가능하다.
  - subtree는 실제 저장소를 복사한 것이다. subtree를 사용하면 다른 저장소를 하나의 저장소로 히스토리와 함께 통합할 수 있다. 통합하게 되면 저장소의 크기는 커지지만 코드와 히스토리를 재사용하기에는 더욱 좋다.


</details>




<details>
<summary>서만기</summary>

### 한 일
- 특화프로젝트 주제선정을 위해 아이디어 제시
  - 뮤지컬, 연극 등 공연 전시 추천 서비스
  - **기획의도** : 현재 뮤지컬, 연극, 뮤직페스티발 등 여러 공연들에 대한 추천은 아직 보지 못한 듯 하다.
  - 좋아하는 뮤지션이나 배우를 골라두면 그 사람의 **공연정보를 추천**(찾아보면 무조건 있을 듯)해주거나 그 사람의 역대 필모그래피(네이버필모그래피 크롤링) 등을 볼 수 있다
  - 공연마다 **장르, 가격대, 위치, 상세정보**를 함께 확인 할 수 있고.
  - 재미있었던 공연의 **평점**을 남기고 **내가 본 공연을 담아두고** 느낀점을 기록할 수 있다.
  - **나의 평점과 비슷한 사람이 본 다른작품**도 추천해주면 좋을 듯 하다.
  - 현재 인기있는 공연정보도 보여주면 좋을 듯 하다.
  - 부가기능으로 표를 살 수 있도록 링크로 옮겨주거나 **남은 자리를 보여줌.**

---

### 배운 것
- [Gold IV] 알파벳 - 1987
- 메모리: 13948 KB, 시간: 1336 ms
- 코드
  ```java
  import java.util.Scanner;
  
  public class Main {
  
  	static int N, M, ans = 0; // 행, 열, 정답
  	static int[][] arr;
  	static boolean[] visited = new boolean[26]; // 알파벳개수만큼 방문체크 배열
  	static int[] drow = { -1, 1, 0, 0 }; // 상하좌우 이동 
  	static int[] dcol = { 0, 0, -1, 1 }; 
  
  	public static void main(String[] args) {
  
  		Scanner sc = new Scanner(System.in);
  
  		N = sc.nextInt();
  		M = sc.nextInt();
  		arr = new int[N][M];
  
  		for (int i = 0; i < N; i++) {
  			String str = sc.next();
  			for (int j = 0; j < M; j++)
  				arr[i][j] = str.charAt(j) - 'A'; // 알파벳을 숫자로 변환하여 배열에 저장
  		}
  
  		alpabet(0, 0, 0); //무조건 0,0에서 시작해서 이렇게 적으면 됨.
  
  		if (N == 1 && M == 1) {
  			System.out.println(1);
  		} else {			
  			System.out.println(ans);
  		}
  		sc.close();
  	}
  
  	public static void alpabet(int i, int j, int count) {
  		if (visited[arr[i][j]]) { // 이미 방문한 알파벳을 만난 경우.
  			if (ans < count) ans = count; // 더 긴 길이이면 정답 갱신해줌.
  			return;
  		} else {
  			for (int d = 0; d < 4; d++) {
  				int x = i + drow[d];
  				int y = j + dcol[d];
  
  				if (x >= 0 && y >= 0 && x < N && y < M) { // 엘스문이라서 범위내에 있는 것만 확인하면 됨.
  					visited[arr[i][j]] = true; // 현재 알파벳 방문체크 
  					alpabet(x, y, count + 1); // 카운트한칸 늘리고 재귀탐.
  					visited[arr[i][j]] = false; // 백트래킹 
  				}
  			}
  		}
  	}
  }

---


</details>


<details>
<summary>심규리</summary>

**한 일**
* 아이디어 회의
  - 가계부 일기장
    1. 우리가 아는 일반적인 가계부 기능
    2. 소비 항목을 보면 그 날 뭘 했는지 알 수 있으니까 일기를 쓰기 쉽다.
    3. 꼭 당일에 일기를 쓰지 않아도 소비 내역을 확인해보면 그날의 기억을 떠올리기 쉬워져 며칠 후에도 생생한 일기 기록 가능
    4. 가계부를 달력으로 표시 - 밑의 사진처럼 매일매일의 기분? 특이한 느낀점을 아이콘으로 표현. 아이콘 밑에 그날의 소비, 소득 숫자로 기록해서 달력으로 표현하면 가계부 느낌이 나지 않을까?
    
    5. 개인 소비 패턴에 맞는 카드나 통장 적금? 아무거나 금융 관련 상품 추천
  - 단체 가계부
    1. 한 모임에 해당하는 인원들이 공동으로 작성하는 가계부
    2. 여행이나 간단 만남 예상 지출액 정해두고 해당액 넘어가면 알람 울리게
    3. 친구의 생일이 다가왔을 때, 다같이 선물 금액 마지노선 입력해두면 금액대에 맞는 선물 추천
* JPA 학습

**배운 것**
1. 데이터 표현 방식의 차이
    - **객체**: 객체 지향 프로그래밍에서 객체는 데이터(속성)와 그 데이터를 처리하는 방법(메소드)을 캡슐화합니다. 객체들은 서로 메시지를 주고받으며 상호작용하고, 복잡한 데이터 구조와 상속, 다형성 같은 개념을 사용하여 실제 세계의 엔티티를 모델링합니다.
    - **관계형 데이터베이스**: 관계형 데이터베이스는 데이터를 테이블로 조직화합니다. 각 테이블은 열(속성)과 행(데이터 레코드)으로 구성되며, 테이블 간의 관계는 외래 키를 통해 표현됩니다. 이러한 구조는 데이터의 정규화, 쿼리 최적화, ACID(Atomicity, Consistency, Isolation, Durability) 속성을 지원하는 등의 장점을 가지고 있습니다.
2. 상속과 다형성
    - **객체**: 객체 지향 프로그래밍은 클래스 간의 상속을 통해 코드 재사용성을 높이고, 다형성을 통해 서로 다른 클래스의 객체가 동일한 인터페이스를 공유할 수 있게 합니다.
    - **관계형 데이터베이스**: 관계형 데이터베이스는 상속이나 다형성을 직접적으로 지원하지 않습니다. 이러한 개념을 데이터베이스에 모델링하기 위해서는 추가적인 테이블 설계나 외래 키 관계를 복잡하게 구성해야 합니다.
3. 데이터 접근 방식의 차이
    - **객체**: 객체 지향 언어에서는 객체의 메소드를 통해 데이터에 접근하고 조작합니다. 이는 데이터와 행위를 하나로 묶는 캡슐화 원칙에 따른 것입니다.
    - **관계형 데이터베이스**: 데이터는 SQL(Structured Query Language) 쿼리를 통해 접근하고 조작합니다. SQL은 선언적 언어로, 데이터를 어떻게 처리할지가 아닌, 어떤 데이터를 가져오거나 조작할지를 기술합니다.


</details>


<details>
<summary>유호정</summary>

**한 일**

* 주제 선정 회의
* JPA 학습
  - JPA 설정하기
  - JPA 구동방식

**배운 것**

* JPA 설정하기
  - persistence.xml : JPA 설정 파일
  - /META-INF/persistence.xml 위치
  - persistence-unit name으로 이름 지정
  - javax.persistence로 시작: JPA 표준 속성
  - hibernate로 시작: 하이버네이트 전용 속성
* JPA 구동방식
  - persistene.xml에서 설정정보 조회
  - EntityManagerFactory 생성
    - 어플리케이션은 단 하나의 EntityManagerFactory를 가지는데, 어플리케이션이 실행하면 생성하고 종료하면 소멸
  - EntityManager 생성 후 요청
    - 실제 DB 사용을 담당하는 EntityManager는 하나의 Thread(Transaction)가 생성될 때마다 EntityManagerFactory가 생성
    - JPA의 모든 데이터 변경은 트랜잭션 안에서 실행


</details>


<details>
<summary>최소영</summary>

**한 일**

* 주제 선정 회의

**배운 것**  

**spring security filter chain**
  - spring security 에서는 인증/인가에 대한 처리를 여러개의 필터를 연쇄적으로 실행
  - WebSecurityConfigurerAdapter를 구현한 설정 파일의 내용을 기반으로 해당 필터를 생성
  - 이때 실제 필터를 생성하는 클래스가 httpSecurity, 각 필터들은 WebSecurity에 전달되어
  filterChainProxy를 생성자의 인자로 전달 -> 각 설정 클래스별 필터 목록을 갖고있는 형식이 됨
  - 사용자의 요청이 들어오면 DelegatingFilterProxy가 가장먼저 요청을 받고 FilterChainProxy에 요청 위임.
    DelegatingFilterProxy는 서블릿 필터로, 위임을 할 때 springSecurityFilterChain bean을 먼저 찾게 됨.
    그것이 "FilterChainProxy", 여기서 체인으로 연결된 필터들이 수행 -> 넘김 -> 수행 -> 넘김 식으로 처리됨
    이때 실행되는 메서드가 "doFilter"

  * SecurityContextPersistenceFilter :
  내부적으로 HttpSessionSecurityContextRepository 클래스를 가짐.
  SecurityContextRepository에서 loadContext 메서드로 인증을 시도한 사용자가 이전에 세션에 저장한 이력이 있는지 확인함!

  * LogoutFilter :
  인증 객체를 만들어서 Authentication 객체를 만들어 아이디 패스워드를 저장하고,
  AuthenticationManager에게 인증처리를 맡김.
  AuthenticationManager가 실질적인 인증을 검증 단계를 총괄하는 클래스인 AuthenticationProvider에게 인증 처리를 위임하고,
  AuthenticationProvider는 UserDetailsService와 같은 서비스를 사용해서 인증을 검증!
  인증에 성공한 결과를 담은 인증객체(Authentication)를 생성한 다음에 SecurityContext에 저장
  인증 후 후속처리는 SessionManagementFilter가 가진 Register SessionInfo, SessionFixation,Concurrentsession을
  인증을 시도하는 당시 동시에 진행

  다른 필터들도 공부하며 차차 정리할 예정 
  * ConcurrentSessionFilter

  * RememberMeAuthenticationFilter

  * RememberMeAuthenticationFilter

  * AnonymousAuthenticationFilter

  * SessionManagementFilter 

  * ExceptionTranslationFilter 
  
</details>




<details>
<summary>최준호</summary>



**한 일**

주제 선정 회의

팀 내에서 프로젝트 주제에 대한 회의를 진행하여 최종 주제를 선정했습니다.
역할 논의

팀원 각자의 역할을 논의하여 프로젝트 진행에 필요한 역할을 분배했습니다.
리액트와 스타일 컴포넌트 학습

리액트에서 스타일 컴포넌트를 활용하는 방법에 대한 학습을 진행했습니다.
각 컴포넌트에 대한 스타일을 스타일 컴포넌트로 정의하고 적용하는 방법을 실습하였습니다.

**배운 것**

리액트와 스타일 컴포넌트 활용
컴포넌트 단위 스타일링:

스타일 컴포넌트를 활용하여 각 리액트 컴포넌트의 스타일을 모듈화하고 캡슐화했습니다.
재사용성 향상:

스타일 컴포넌트를 사용함으로써 각각의 컴포넌트 스타일을 독립적으로 관리하고 재사용성을 높였습니다.
가독성과 유지보수성 향상:

스타일과 컴포넌트가 하나로 관리되어 코드의 가독성과 유지보수성을 향상시켰습니다.

**아직 잘 모르는 것**

리액트에서의 스타일 컴포넌트로 프로젝트를 진행하는 법이 자바스크립트만큼 매끄럽지 않음:
리액트와 스타일 컴포넌트를 함께 사용하며 프로젝트를 진행하는 부분에서 아직 익숙하지 않은 부분이 있어, 추가적인 학습과 경험을 통해 이 부분을 극복해 나갈 계획입니다.



</details>


## 2024-02-29 (목)

<details>
<summary>고은석</summary>

**한 일**

- 주제 선정 회의
- 추천 알고리즘 학습

**배운 것**
- 컨텐츠 기반 추천 시스템 (Contents-based Recommend System) : 사용자가 과거에 좋아했던 아이템을 파악하고 그 아이템과 비슷한 아이템을 추천한다.
- 협업 필터링 추천 시스템 (Collaborative Filtering Recommend System) : 유사한 성향 또는 취향(관심사)을 갖는 다른 사용자가 좋아한 아이템을 현재 사용자에게 추천
  - Memory-based : 사용자가 아이템을 좋아하거나 평가했는지 또는 특정 사용자가 항목을 좋아하거나 평가했는지 여부와 같은 사용자 행동을 관찰한다. 전처리 없이 raw-data에 적용, 구현하기 쉽고 추천 결과를 설명하기 쉽다는 장점이 있다.
    - User-based : 사용자와 유사한 사용자가 '구매/좋아요' 했다는 사실을 기반으로 사용자에게 추천
    - Item-based :  "이 항목을 좋아한 사용자가 ###도 좋아했습니다" . 사용자는 마음을 바꿀 수 있기 때문에  User-based(사용자 기반)보다 더 안정적이며 새로운 사용자가 사이트를 방문한 경우, User-based보다 더 나은 방식이다.

</details>

<details>
<summary>서만기</summary>

### 한 일
- 특화프로젝트 주제선정을 위해 아이디어 회의
- 그동안 나온 아이디어를 모아서 하나로 추리는 과정을 진행.
- 추천 알고리즘 공부
---

### 배운 것
- 추천 시스템의 종류

**Contents-based Recommender System (컨텐츠 기반 추천시스템)**

- **사용자가 과거에 좋아했던 아이템**을 파악하고 그 아이템**과 비슷한 아이템을 추천**한다.
- 예시) '부산행'에 5점 평점을 준 사용자 → '명량' 보다는 '반도'를 더 좋아할 것이다.
- ① 사용자가 과거에 접한 아이템이면서 만족한 아이템 ② 사용자가 좋아했던 아이템 중 일부 또는 전체와 비슷한 아이템 선정 ③ 선정된 아이템을 유저에게 추천
- Content-based Recommender System

- Input : 사용자의 Item들에 대한 등급Output : 사용자의 등급 매기는 행위에 맞는 classifier를 생성

**Collaborative Filtering Recommemder System (협업필터링 추천시스템)**

- **유사한 성향 또는 취향(관심사)을 갖는 다른 사용자가 좋아한 아이템**을 현재 사용자에게 추**천**
- 예시) '부산행'에 5점 평점을 준 2명의 사용자 → 사용자 A가 과거 좋아했던 '반도'를 유저 B에게 추천
- ① 사용자 A와 사용자 B 모두 같은 아이템에 대해 비슷한 또는 같은 평가를 했다. ② 이때, 사용자 A는 다른 아이템에도 비슷한 호감을 나타냈다. ③ 따라서, 사용자 A, B의 성향을 비슷할 것이므로, 다른 아이템을 사용자 B에게 추천한다.
- Implicit Feeback이 적절
- Input : 아이템들에 대한 사용자들의 등급Output : 사용자와 비슷한 다른 사용자들을 판별, 그들의 아이템 등급
- Steps :① 사용자-아이템 평가 매트릭스 만들기 ② 사용자-사용자 유사성 메트릭스, 코사인 유사도 계산 ③ 유사한 사용자 탐색 ④ 후보자 생성(유사한 사용자가 접한 아이템들의 ranking을 살핌)⑤ 후보자 점수화(유사한 사용자가 가장 좋아하는 아이템부터 덜 좋아하는 책까지 순위 매김) ⑥ 후보 필터링 (이미 사용자가 접한 아이템은 제거)


</details>


<details>
<summary>심규리</summary>

**한 일**

- 주제 선정 회의
    - 제안내용 : 농산물 레시피 추천
    - 주요기능
        - 농산물 데일리 가격 정보 제공
        - 매일 저렴한 농산물을 활용한 데일리 레시피 추천
        - 농산물 검색 기능 -> 엘라스틱서치 활용(농산물 검색 시 해당 농산물로 만들 수 있는 레시피 추천)
        - 내가 이미 가지고 있는 농산물로 어떤 음식을 만들 수 있는지 레시피 추천
    - 장바구니 속 식재료 가격 예측 및 장보기 계획 기능 추가

- JPA 학습
    - JPA의 CRUD

**배운 것**

- CRUD
    - 저장 : jpa.persist(member)
    - 조회 : Member member = jpa.fine(memberId)
    - 수정 : member.setName(”변경할 이름”)
    - 삭제 : jpa.remove(member)
- JPA를 사용했을 때 장점
    - JPA와 패러다임의 불일치 모두 해결
      - - JPA와 상속
      - JPA와 연관 관계
      - JPA와 객체 그래프 탐색
      - JPA와 비교하기
    - JPA의 성능 최적화 기능(memberId)
      - 1차 캐시와 동일성 보장(같은 트랜잭션 안에서는 같은 엔티티를 반환함 - 약간의 조회 성능 향상)
      - 트랜잭션을 지원하는 쓰기 지연(트랜잭션을 커밋할 때까지 INSERT SQL을 모음, 한번에 전송)
      - 지연 로딩과 즉시 로딩  
        -  지연 로딩 : 객체가 실제 사용될 떄 로딩
        -  지연 로딩 : 객체가 실제 사용될 떄 로딩

**앞으로 공부할 것**
- 추천 알고리즘의 종류
  (추천 시스템의 구조와 종류, 동작 방식에 대해 공부할 예정)

</details>

<details>
<summary>유호정</summary>

**한 일**

- 주제 선정 회의
    - 제안내용 : 문학작품 (시, 소설, 수필 등) 추천
    - 주요기능
        - 가입할때 관심사 등록 해당 관심사와 비슷한 책과 문학작품(시, 소설, 수필 등) 추천
        - 해당 책 있는 근처 도서관이나 온라인 도서관, 온/오프라인 서점 등의 정보 제공
        - 해당 작품이 마음에 들었으면 좋아요,별점 등을 통해 마이페이지에 저장 → 해당 데이터를 바탕으로 조금더 세밀하게 추쳔할 수 있으면 좋을것 같다
        - 작품에 대한 감상평이나 이런거 나눠볼 수 있도록 리뷰작성도 넣기
    
    - 차별점을 위한 추가기능(다 구현하진 않아도 하나쯤 있으면 좋을 기능들)
        - 읽은 작품의 다음편을 써보거나 함께 다음 내용에 대한 이야기 나누어보기
        - 함께 작품 분석해보기
        - 읽은 작품의 일러스트 그려보기(내가 머리속으로 상상한 문학작품의 모습 표현)
- JPA 학습
    - JPQL

**배운 것**

- JPQL
    - 가장 단순한 조회 방법
    - EntityManager.find()
    - 객체 그래프 탐색(a.getB().getC())
    - JPA는 SQL을 추상화한 JPQL이라는 객체 지향 쿼리 언어 제공
    - SQL과 문법 유사, SELECT, FROM, WHERE, GROUP BY, HAVING, JOIN 지원
    - **JPQL은 엔티티 객체를 대상으로 쿼리**
    - **SQL은 데이터베이스 테이블을 대상으로 쿼리**
    - 테이블이 아닌 객체를 대상으로 검색하는 객체 지향 쿼리
    - SQL을 추상화해서 특정 데이터베이스 SQL에 의존하지 않음
    - JPQL을 한마디로 정의하면 객체 지향 SQL

</details>


<details>
<summary>최소영</summary>

**배운 것**

- Observer Pattern??
    - 옵저버 패턴(observer pattern)은 객체의 상태 변화를 관찰하는 관찰자들, 즉 옵저버들의 목록을 객체에 등록하여 상태 변화가 있을 때마다 메서드 등을 통해 객체가 직접 목록의 각 옵저버에게 통지하도록 하는 디자인 패턴이다. 주로 분산 이벤트 핸들링 시스템을 구현하는 데 사용됨. 발행/구독 모델로 알려져 있기도 하다.
    - 어떤 객체의 상태가 변할 때 그와 연관된 객체 들에게 알림을 보내는 디자인 패턴
    - 객체의 상태가 변화될 때 연관된 객체 들에게 알림을 보낼 수 있게 된다.
    - 사용 이점
      - 객체간의 결합도를 낮출 수 있고 시스템의 확장성과 유연성을 높일 수 있음
    - 어떻게 이용될까?
      - Event-driven System
      - MSA 아키텍처에서 서비스 간 결합도를 낮추기 위해서 사용가능한듯
      - 시스템 내부 비동기 처리
      - 리소스 상태 관리

</details>

<details>
<summary>최준호</summary>

**한 일**

- 주제 선정 회의
    - 제안내용 : 칵테일 추천 시스템
    - 주요기능
        - 가입할때 관심사 등록 해당 관심사와 비슷한 칵테일 추천
        - 그날의 기분, 날씨, 온도에 따라 칵테일 추천
    
    - 차별점을 위한 추가기능
        - 유성구 주변의 칵테일집 분석 및 제안
- TypeScript 학습
    - TypeScript

**배운 것**

- TypeScript
    - 기존에 있는 코드에 타입을 집어넣고 실행해보았다.

</details>


## 2024-03-01 (금)
삼일절